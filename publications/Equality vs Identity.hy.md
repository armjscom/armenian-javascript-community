# Հավասարության (equality) և խիստ հավասարության (identity) օպերատորները JavaScript-ում։ ES6 ստանդարտում ստեղծվել է նոր մեթոդ՝ Object.is, որի օգնությամբ կարելի է համեմատել մեծություններն ինչպես խիստ հավասարության դեպքում: Այնուամենայնիվ որոշակի տարբերություններ կան խիստ հավասարության օպերատորի և Object.is մեթոդի միջև, կխոսենք նաև այդ մասին:

**JavaScript**-ում ի տարբերություն մի շարք այլ դասական ծրագրավորման լեզուների գոյություն ունի հավասարության ստուգման երկու օպերատորներ՝ **==** (**equality**) և **===** (**identity**): Խիստ հավասարության օպերատորի առկայության անհրաժեշտությունը բխում է **Javascript**-ի որդեգրած _թույլ տիպաբանության_ փիլիսոփայությունից։

Քանի-որ լեզվի տիպաբանությունը թույլ է, ցանկացած համեմատություն կատարելու ժամանակ, եթե տիպերը չեն համընկնում, ապա լեզվի ինտերպրետատորը փորձում է կատարել տիպերի վերափոխում, ինչի արդյունքում մենք օրինակ կարող ենք ստանալ, որ _2 == "2"_, կամ _0 == false_, թեև բոլորիս համար էլ պարզ է, որ օպերանդները պատկանում են տարբեր տիպերի, և տրամաբանորեն չպետք է հավասար լինեյին։ Այդ բոլոր վերափոխումները կատարվում են **ECMAScript** ստանդարտի խստորեն սահմանված կանոններով։

Ստանդարտին ոչ ծանոթ կամ ուժեղ տիպաբանությամբ ծրագրավորման լեզվից հետո **JavaScript** լեզուն սովորողի համար այս ամենը կարող է տարօրինակ թվալ, սակայն անկեղծ ասած այստեղ ոչ մի տարօրինակություն էլ չկա, սա լեզվի յուրօրինակ կառուցվածք է, որն ամենայն մանրամասնությամբ նկարագրվում է ստանդարտի մեջ։ Թերևս մինչև սխալ եզրահանգումներ անելը, որ իբր լեզուն ունի անկանխատեսելի վարքագիծ, շատ վատն է, կամ ամենավատն է բոլոր հանրաճանաչ ծրագրավորման լեզուների մեջ, արժեր ծանոթանալ ստանդարտին և հասկանալ թե այդ փոխակերպումներն ինչպես են տեղի ունենում։

Հավասարության (_equality_) օպերատորի կիրառումը շատ հաճախ կարող է պատճառ դառնալ դժվար որսացվող սխալների, ծրագրի մասը կարող է աշխատել ոչ այն տրամաբանությամբ, ինչպես նախատեսել ենք։ Դրա համար շատ ավելի նախընտրելի է կոդում օգտագործել խիստ հավասարության օպերատորը (_identity_): Այն չի կատարում տիպերի վերափոխում, և եթե մեծությունները պատկանում են տարբեր տիպերի, անհապաղ վերադարձնում է _false_: Օրինակ վերը նշված `2 === "2"` և `0 === false` արտահայտությունները վերադարձնում են _false_, ինչը շատ ավելի տրամաբանական է, շատ ավելի անվտանգ, քանի-որ այսպիսով ծրագիրը զերծ կմնա տիպերի վերափոխումների արդյունքում առաջացող տարբեր անակնկալներից։

**JavaScript - The Good Parts** գրքի հեղինակ, **JavaScript** լեզվի զարգացման գործում մեծ ավանդ ունեցած, **JSON** ֆորմատի, **JSLint** անալիզատորի և **JSMin** մինիֆիկատորի ստեղծող հանրաճանաչ ծրագրավորող **Դուգլաս Քրոքֆորդը** խորհուրդ է տալիս երբեք չօգտագործել հավասարության == և անհավասարության != օպերատորները, դրանք փոխարինելով խիստ հավասարության === և խիստ անհավասարության !== օպերատորներով։

**Object.is** մեթոդն ավելացվել է **ES6** ստանդարտում, այն ընդունում է երկու արգումենտ և ստուգում նրանց հավասարությունը, վերադարձնելով բնականաբար բուլյան արժեք՝ _true_ կամ _false_: Սինթաքսն ունի հետևյալ տեսքը՝

`Object.is(value1, value2)`;

- որտեղ _value1_-ը և _value2_-ն արժեքներն են, որոնք պահանջվում է համեմատել։

**Object.is** մեթոդն իրեն դրսևորում է գրեթե նույն կերպ, ինչպես որ խիստ հավասարության օպերատորը, սակայն ունի նաև որոշ տարբերություններ։ Այն _0_-ն և _-0_-ն համեմատելիս վերադարձնում է _false_, այն դեպքում, երբ խիստ հավասարության օպերատորը դրանք իրարից չի տարբերում։

```js
0 === -0; // true
0 == -0; // true
Object.is(0, -0); // false
```

Մեթոդը նաև կարողանում է համեմատել հատուկ թվային արժեք _NaN_-ը։ Հիշեցնեմ որ թե՛ հավասարության,և թե՛ խիստ հավասարության օպերատորները համարում են, որ _NaN_-ը ոչ մի դեպքում հավասար չէ _NaN_-ի՝

```js
NaN === NaN; // false
NaN == NaN; // false
Object.is(NaN, NaN); // true
```

**Object.is** մեթոդը կիրառելի է հիմնականում հատուկ դեպքերում՝ օրինակ մետածրագրավորման մեջ, իսկ սովորաբար շատ ավելի հարմար և պրակտիկ կլինի կիրառել խիստ հավասարության օպերատորը։ **Դուգլաս Քրոքֆորդն** իր **«How JavaScript works»** գրքի մեջ խորհուրդ է տալիս հրաժարվել նաև այս մեթոդի կիրառությունից, քանի-որ _0_-ի և _-0_-ի տարբերակումը կարող է սխալների պատճառ դառնալ։ Անգամ եթե կոդի մեջ անհրաժեշտ կլինի համեմատել _NaN_ հատուկ թվային արժեքները, ճիշտ կլինի նախապատվությունը տալ բոլորիս քաջ հայտնի _isNaN_ մեթոդին։
